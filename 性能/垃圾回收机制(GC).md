
## 垃圾回收机制

`Javascript`具有自动垃圾回收机制(`GC: Garbage Collection`),执行环境会负责管理代码执行
过程中使用的内存

### 原理
  
垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其占用的内存
过程不复杂，但开销比较大，所以固定时间间隔周期性执行垃圾回收
    
### 方式
#### 标记清除

最常用的垃圾回收方式，当变量进入执行环境中，GC会标记其为“进入环境”，当变量离开时（函数执行完毕），
将其标记为“离开环境”，分为两个阶段：`标记阶段mark`和`清除阶段sweep`

- 缺陷
  
  GC时，为了安全考虑，JS运行线程会挂起，停止其他运行的程序，对于JS游戏则需要优化GC长时间挂起

+ [相关算法文章](http://www.softwhy.com/article-6553-1.html)

##### 1、标记阶段(mark and sweep)

GC会从应用程序(mutator)根开始遍历，凡是能够从根访问到的对象都会增加一个标识，被称为可到达对象

##### 2、清除阶段

GC会对堆内存从头到尾的线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收
并将原来标记为可到达对象的标识清除，以进行下一次垃圾回收处置

附图：

<div align=center>
<img src="http://www.softwhy.com/data/attachment/portal/201704/10/130136v16uyge0d6naeodd.png">
</div>      

在标记阶段，从跟对想1可以访问到B，从B又可以访问到E，那么B和E都是可到达对象，同样的道理，F、G、J和K都是可到达对象。
在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收。

#### 引用计数(reference counting)

跟踪记录每个值被引用的次数。定义变量，将一个引用类型值赋给它时，值的引用次数就是1。
如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含
对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，将其
占用的内存空间回收回来。当垃圾回收器下次再运行时,它就会释放那些引用次数为0的值所占用的内存。

    function test(){
     var a = {} // a的引用次数为 0
     var b = a  // a的引用次数加 1，为 1 
     var c = a  // a的引用次数再加 1，为 2
     var b = {} // a的引用次数减 1，为 1
    }

- 循环引用的问题
 
  NetScape Navitator3 最早使用计数策略的浏览器；
  
  循环引用是指对象A的指针指向对象B的指针，而对象B中也有一个指针指向对象A的引用
  
         function fn() {
          var a = {}
          var b = {}
          a.pro = b // a的引用次数2
          b.pro = a // b的引用次数2
         }
          
         fn()

 以上a、b 的引用次数都是2，fn()指向完毕后，这俩引用次数不为0，不会被GC回收内存
 ie7/8 函数大量调用后，内存直线上升


